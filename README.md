# AskQuestions
# 介绍项目：
问答社区是一个用户提问，其他人可以回答也可以评论的一个网站，功能类似知乎。
## 一  基于SpringBoot+MyBatis+Redis
基于SpringBoot和MyBatis来搭建，数据库使用MySQL+Redis
## 二  注册登录
首先有用户注册登录的功能，用户登录验证这块没有用框架，是自己实现的。

1、用户注册时的密码会加密然后再存入数据库，加密的方式是MD5（明文+随机的salt），MD5是一种Hash散列方式。
1）随机的salt通过UUID.randomUUID().toString.subString(0,5)生成，即做salt也可以用来生成全局唯一的T票。
2）然后salt也要存在数据库里，因为验证密码的时候要取出来与密码相加计算MD5后的结果做比较。
3）UUID.randomUUID().toString()介绍：UUID是全局唯一标识符，保证同一时空中所有的机器生产的都是唯一的，由一下几部分组成：当前日期和时间，时钟序列，全局唯一的IEEE机器识别号（如果有网卡，从网卡获得，没有网卡从其他方式获得）
 
 2、用户登录时验证登录信息，如果用户名和密码有问题，会把信息返回给前台。所以用Map<String, Object>来作为返回类型。
如果验证成功会生成一个ticket，（单独的一张表）里面存用户id，ticket值，过期时间，状态（是否过期），如果过期要重新生成。这个ticket存在Cookie里面。

3、另有一个拦截器，放在所有controller的最前面，每个请求过来会首先检查Cookie里面的T票，如果有就去数据库里查，查到结果后，如果没有过期，就把当前用户对象放到一个HostHolder对象里面，对象里有一个ThreadLocal类型的变量，用来保存已经认证过的用户信息。
HostHolder用来存当前用户是谁。 * 服务器不是一个人在用，一个人在浏览，另一个人也在浏览，那么这个user应该存在哪里呢？* 所以每个user存在自己的线程里。 * ThreadLocal 用一种存储变量与线程绑定的方式，在每个线程中用自己的 ThreadLocalMap 安全隔离变量，为解决多线程程序的并发问题提供了一种新的思路，如为每个线程创建一个独立的数据库连接。因为是线程绑定的，所以在很多场景也被用来实现线程参数传递，如 Spring 的 RequestContextHolder。也因为每个线程拥有自己唯一的 ThreadLocalMap ，所以 ThreadLocalMap 是天然线程安全的。

需要把拦截器注册到spring mvc中。
MVC的注册可以通过自动配置的方式。
在configuration包中加入ToutiaoWebConfiguration类。
继承WebMvcConfigurerAdapter类，实现addInterceptor方法。
把Interceptor注册进来，注册以后， 每次请求都会回调一遍。
定义为@Component
@component （把普通pojo实例化到spring容器中，相当于配置文件中的<bean id="" class=""/>）

4、经过这个拦截器，那么登录用户都会有一个线程私有的Holder，没有登录的话就没有。所以再定义一个拦截器，检查Holder，有就继续，没有就重定向至登录页面。

拦截器正常执行时拦截器方法的执行顺序为：配置文件中在前面的拦截器的preHandle()方法先执行，然后根据配置文件中拦截器的顺序依次执行拦截器的preHandle()方法，等所有拦截器的preHandle()方法执行完成后，逆序执行每个拦截器的postHandle()方法，当所有postHandle()方法执行完成后，再逆序执行afterCompletion()方法

## 三 评论中心
之所以叫评论中心，是因为这个评论中心是通用的。可以是新闻的评论，也可以是评论的评论。等。
所以有entity_id entity_type 而不是 newsid或其他。
评论的实体是什么？和该实体的id。

## 四 Redis实现踩赞
JedisAdapter类来实现通用的Redis操作，通过Jedis连接池来实现。
注意Redis的事务的两个实现方法，multi开启事务和exec提交事务，exec执行以上事务命令，返回一个list的Object，每个命令对应一个Object。

1）踩赞使用是Redis的set的数据结构，key是由对象的id生成的点赞key，value是用户的id，用set的数据结构可以防止用户重复点赞点踩。sadd函数可以向set里面添加value，srem函数可以向set里面删除value。统计某个回答的总的点赞数可以使用scard函数。
判断用户是否给这篇回答点过赞，用sismenber命令同时查询赞和踩的情况，如果点了赞返回1，点踩返回-1，如果即每月赞，也没有踩，返回0。

2）用户关注这里用到了有序的zset结构，添加了时间，这样既可以防止重复关注，还能根据时间先后来排序粉丝。另外Redis提供了求交集、并集等集合操作，因此可以方便地实现共同好友、共同关注等功能。
因为A关注B，A和关注列表多一个人，和B的粉丝列表多一个人要同时实现，因此要用到Redis事务
Redis事务实现原理：
a 批量操作在发送exec命令前被放入队列缓存
b 由 EXEC 命令触发事务， 一并执行事务中的所有命令。单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。
c 可以使用discard命令来取消事务，放弃事务块内的所有命令。
获取我的关注列表，用zrevrange（key，startIndex，endIndex）来获取。zrevange安装分值从大到小来排序，zrange按照分值从小到大排序。

## 五 敏感词过滤
针对用户发布的内容，使用前缀树算法，实现了敏感词过滤
（1）前缀树的时间复杂度O（n），但是要存储目标串，空间消耗很大
（2）类似的还有KMP算法，时间复杂度O（m+n），m是模板串的长度，n是内容的长度，但是敏感词有多个，不适合用KMP算法。
（3）不在意空间，只在意速度的话可以使用前缀树。

前缀树：
* 根节点不包含字符，除根节点外每一个节点都只包含一个字符
* 从根节点到某一个节点，路径上经过的字符串连接起来，为该节点对应的字符串
* 每个节点的所有子节点包含的字符都不相同
（4）多个敏感词组成前缀树，要注意尾节点，要标记一下，表示这是敏感词的最后一个字母。不能用null来判断。中午也是一个字符存一个节点。
在内容字符串是用两个指针来进行判断，与前缀树上的字符做比较，可以用一个StringBuilder来存结果，过一个字符，就存一个字符。

## 六 异步消息队列
针对站内信，发送邮件（要连接邮箱服务器）等较慢或不需要立即返回的事件的时候，可以防止异步来做。
为了提升效率，做了一个小的异步框架，相当于一个简单的消息队列。
这个异步队列有什么优点呢？第一，它是异步的，可以延迟处理一下事件，提供用户体验；第二，可以注册各种类型的事件，消费者能够处理多种事件（点赞，关注，站内信等）；第三，这个异步框架使用了Redis的list数据结构，也可以用BlockingQueue。
（1）首先定义了一个枚举类型的EventType，事件类型（点赞，评论站内信，邮件，取关等），当有新的事件需要处理的时候，可以在这个枚举类里面添加。
（2）定义通用的事件处理EventModel，事件的发生者id，实体类型，实体id，ownerid，扩展信息等信息
（3）定义事件的生产者EventProducer，是一个@Service，有一个fireEvent方法，把EventModel序列化后写入Redis队列中
（4）定义事件处理接口，EventHandler，有两个方法doHandle，处理事件，getSupportEventTypes注册自己，让别人知道自己是关注哪些eventType的。当这些类型的事件发生后要进行处理。
（5）定义事件消费者EventConsumer，要实现InitializingBean在初始化的时候就调用这个类的afterPropertiesSet方法，该方法启动一个线程，
a 首先通过applicationContext找出所有的Handler的实现类
b 然后把Handler与各个事件关联起来
c new一个线程，不断从Redis里面brpop（）出Key = Eventqueue，如果有，把value取出来，反序列化成一个EventModel，并传入对应的Handler处理。因为这个类实现了InitializingBean，一开始这个线程就会起来永久运行。
## 七 实现了“推”和“拉”两种模式来展示新鲜事
当用户发布问题或者关注问题的时候，这个用户就产生了一个新鲜事。
（1）首先会把新鲜事存入数据库
定义一个Feed的Model，代表用户产生的新鲜事。
（2）然后写FeedService，实现推拉模式
（3）实现一个事件监听器（FeedHandler）当产生评论或关注问题的事件的时候，把事件存入feed的数据库里面。
（4）“拉”模式，当我要显示新鲜事的时候，我会先查找我关注的多少人，从我关注的人里面把新鲜事渲染出来。
获取所有关注人的user_id，作为一个list传入SQL，在数据库查这些新鲜事，并排序返回，限制条数。
MySQL5.7及以上不支持子查询中order by 模式下查询排序，5.6就可以。
（5）“推”模式，首先获取产生新鲜事的用户的所有粉丝id，遍历这些id，给每个id其对应的Redis里面的timeline的key。用户查看自己的新鲜事，就是看自己TimelineKey的value对应的feed的ID，然后根据新鲜事的id从数据库获取具体信息。
存的时候用lpush操作，从队列左边存入新鲜事，取的时候用lrange（TimelineKey，0，10），取10条新鲜事。
